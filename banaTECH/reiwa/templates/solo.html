{% extends "base.html" %}
{% block title%}
令和(ひとりで)
{% endblock %}

{% block head %}
<meta name="description" content="後で書く">
{% load static %}
<script src="https://cdn.jsdelivr.net/npm/@tensorflow/tfjs@1.0.0/dist/tf.min.js"></script>
{% endblock %}

{% block content %}
<div id="container" class="container" style="touch-action: manipulation;">
    <div class="d-frex" style="text-align:center;background-color:#CC9966;">
        <div class="row m-0">
            <div class="col-8">
                <canvas id="can" width="128px" height="256px"></canvas>
            </div>
            <div class="col-4">
                <ul class="list-group">
                    <li class="list-group-item">あと<br><span id="deadline">100</span>秒</li>
                    <li class="list-group-item"><span id="count">0</span>枚</li>
                </ul>
                <button type="button" class="btn btn-primary" onClick="submit();">提出</button>
                <button type="button" class="btn btn-danger" onClick="clearCan();">クリア</button>
            </div>
        </div>
    </div>
</div>
<script>
    var can;
    var wrap;
    var ct;
    var ox = 0,
        oy = 0,
        x = 0,
        y = 0;
    var mf = false;
    var sub = false; //提出状態かどうか
    var count = 0; //書いた数
    var time = 100;
    var canW, canH;
    onload = function () {
        can = document.getElementById("can");
        canH = window.innerHeight * 2 / 3;
        canW = canH / 2;
        can.width = canW;
        can.height = canH;
        mam_draw_init();
    }

    function mam_draw_init() {
        //初期設定
        can = document.getElementById("can");
        can.addEventListener("touchstart", onDown, false);
        can.addEventListener("touchmove", onMove, false);
        can.addEventListener("touchend", onUp, false);
        can.addEventListener("mousedown", onMouseDown, false);
        can.addEventListener("mousemove", onMouseMove, false);
        can.addEventListener("mouseup", onMouseUp, false);
        can.addEventListener("mouseleave", onMouseUp, false);
        ct = can.getContext("2d");
        ct.strokeStyle = "#000000";
        ct.lineWidth = 7 * can.width / 128;
        ct.lineJoin = "round";
        ct.lineCap = "round";
        clearCan();
    }

    function onDown(event) {
        if (!sub) {
            mf = true;
            ox = event.touches[0].pageX - event.target.getBoundingClientRect().left;
            oy = event.touches[0].pageY - event.target.getBoundingClientRect().top;
            event.stopPropagation();
        }
    }

    function onMove(event) {
        if (mf) {
            x = event.touches[0].pageX - event.target.getBoundingClientRect().left;
            y = event.touches[0].pageY - event.target.getBoundingClientRect().top;
            drawLine();
            ox = x;
            oy = y;
            event.preventDefault();
            event.stopPropagation();
        }
    }

    function onUp(event) {
        mf = false;
        event.stopPropagation();
    }

    function onMouseDown(event) {
        if (!sub) {
            ox = event.clientX - event.target.getBoundingClientRect().left;
            oy = event.clientY - event.target.getBoundingClientRect().top;
            mf = true;
        }
    }

    function onMouseMove(event) {
        if (mf) {
            x = event.clientX - event.target.getBoundingClientRect().left;
            y = event.clientY - event.target.getBoundingClientRect().top;
            drawLine();
            ox = x;
            oy = y;
        }
    }

    function onMouseUp(event) {
        mf = false;
    }

    function drawLine() {
        ct.beginPath();
        ct.moveTo(ox, oy);
        ct.lineTo(x, y);
        ct.stroke();
    }

    function clearCan() {
        if (!sub) {
            ct.fillStyle = "rgb(255,255,255)";
            ct.fillRect(0, 0, can.getBoundingClientRect().width, can.getBoundingClientRect().height);
        }
    }

    function strokeCircle(num) { //num:何文字目か
        var p;
        if (num == 0) {
            p = 0;
        } else {
            p = canW;
        }
        ct.beginPath();
        ct.arc(canW / 2, canW / 2 + p, canW * 3 / 8, 0, Math.PI * 2, false);
        ct.strokeStyle = 'red';
        ct.stroke();
        ct.strokeStyle = 'black';
    }

    function strokeCross(num) { //num:何文字目か
        var p;
        if (num == 0) {
            p = 0;
        } else {
            p = canW;
        }
        var x = canW / 8;
        ct.beginPath();
        ct.moveTo(x * 2, x + p);
        ct.lineTo(x, x * 2 + p);
        ct.lineTo(x * 3, x * 4 + p);
        ct.lineTo(x, x * 6 + p);
        ct.lineTo(x * 2, x * 7 + p);
        ct.lineTo(x * 4, x * 5 + p);
        ct.lineTo(x * 6, x * 7 + p);
        ct.lineTo(x * 7, x * 6 + p);
        ct.lineTo(x * 5, x * 4 + p);
        ct.lineTo(x * 7, x * 2 + p);
        ct.lineTo(x * 6, x + p);
        ct.lineTo(x * 4, x * 3 + p);
        ct.fillStyle = 'blue';
        ct.fill();
    }

    function submit() {
        if (sub == false) {
            sub = true;
            var temp = document.createElement('canvas');
            temp.width = 32;
            temp.height = 64;
            var tempCtx = temp.getContext('2d');
            tempCtx.drawImage(can, 0, 0, temp.width, temp.height);
            var imageData = tempCtx.getImageData(0, 0, temp.width, temp.height);
            for (var i = 0; i < imageData.data.length / 4; i++) {
                var r = imageData.data[i * 4];
                var g = imageData.data[i * 4 + 1];
                var b = imageData.data[i * 4 + 2];
                imageData.data[i * 4] = (r + g + b) / 3;
                imageData.data[i * 4 + 1] = (r + g + b) / 3;
                imageData.data[i * 4 + 2] = (r + g + b) / 3;
            }
            var inputTensor = tf.browser.fromPixels(imageData, 3).toFloat();
            inputNormTensor = inputTensor.div(tf.scalar(255));
            var [reiTensor, waTensor] = tf.split(inputNormTensor, 2);
            reiTensor = reiTensor.reshape([1, 32, 32, 3]);
            waTensor = waTensor.reshape([1, 32, 32, 3]);
            loadPretrainedModel();
            async function loadPretrainedModel() {
                const model = await tf.loadLayersModel("{% static 'reiwa/model/model.json' %}");
                const reiPrediction = model.predict(reiTensor, {
                    batchSize: 1
                });
                const waPrediction = model.predict(waTensor, {
                    batchSize: 1
                });
                const rei1 = reiPrediction.arraySync()[0][0];
                const rei2 = reiPrediction.arraySync()[0][1];
                const wa = waPrediction.arraySync()[0][2];
                if ((rei1 > 0.9 || rei2 > 0.9) && wa > 0.9) {
                    count += 1;
                    document.getElementById("count").innerHTML = count;
                    strokeCircle(0);
                    strokeCircle(1);
                } else {
                    if ((rei1 > 0.9 || rei2 > 0.9)) {
                        strokeCircle(0);
                    } else {
                        strokeCross(0);
                    }
                    if (wa > 0.9) {
                        strokeCircle(1);
                    } else {
                        strokeCross(1);
                    }
                }
                setTimeout(function () {
                    sub = false;
                    clearCan();
                }, 2000);
            }
        }
    }
</script>
{% endblock %}