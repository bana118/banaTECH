{% extends "base.html" %}
{% block title%}
令和(ひとりで)
{% endblock %}

{% block head %}
<meta name="description" content="後で書く">
{% load static %}
<script src="https://cdn.jsdelivr.net/npm/@tensorflow/tfjs@1.0.0/dist/tf.min.js"></script>
{% endblock %}

{% block content %}
<div class="container" style="touch-action: manipulation;">
    <div class="d-frex start" style="position:relative;text-align:center;background-color:#CC9966;">
        <canvas id="can" width="128px" height="256px" style="max-width:100%;max-height:100%;margin:auto;"></canvas>
        <button type="button" class="btn btn-primary" style="text-align:center;" onClick="submit();">提出</button>
        <button type="button" class="btn btn-danger" style="text-align:center;" onClick="clearCan();">クリア</button>
    </div>
    <h1>令和～THE REIWA～</h1>
    <p>ルール：</p>
    <p>制作記事：</p>
    <p>操作方法（キーボード）</p>
    <p>操作方法（ボタン）</p>
    <p>効果音：</p>
    <p>BGM：</p>
</div>
<script>
    var can;
    var wrap;
    var ct;
    var ox = 0,
        oy = 0,
        x = 0,
        y = 0;
    var mf = false;
    onload = function () {
        mam_draw_init();
    }

    function mam_draw_init() {
        //初期設定
        can = document.getElementById("can");
        can.addEventListener("touchstart", onDown, false);
        can.addEventListener("touchmove", onMove, false);
        can.addEventListener("touchend", onUp, false);
        can.addEventListener("mousedown", onMouseDown, false);
        can.addEventListener("mousemove", onMouseMove, false);
        can.addEventListener("mouseup", onMouseUp, false);
        can.addEventListener("mouseleave", onMouseUp, false);
        ct = can.getContext("2d");
        ct.strokeStyle = "#000000";
        ct.lineWidth = 8;
        ct.lineJoin = "round";
        ct.lineCap = "round";
        clearCan();
    }

    function onDown(event) {
        mf = true;
        ox = event.touches[0].pageX - event.target.getBoundingClientRect().left;
        oy = event.touches[0].pageY - event.target.getBoundingClientRect().top;
        event.stopPropagation();
    }

    function onMove(event) {
        if (mf) {
            x = event.touches[0].pageX - event.target.getBoundingClientRect().left;
            y = event.touches[0].pageY - event.target.getBoundingClientRect().top;
            drawLine();
            ox = x;
            oy = y;
            event.preventDefault();
            event.stopPropagation();
        }
    }

    function onUp(event) {
        mf = false;
        event.stopPropagation();
    }

    function onMouseDown(event) {
        ox = event.clientX - event.target.getBoundingClientRect().left;
        oy = event.clientY - event.target.getBoundingClientRect().top;
        mf = true;
    }

    function onMouseMove(event) {
        if (mf) {
            x = event.clientX - event.target.getBoundingClientRect().left;
            y = event.clientY - event.target.getBoundingClientRect().top;
            drawLine();
            ox = x;
            oy = y;
        }
    }

    function onMouseUp(event) {
        mf = false;
    }

    function drawLine() {
        ct.beginPath();
        ct.moveTo(ox, oy);
        ct.lineTo(x, y);
        ct.stroke();
    }

    function clearCan() {
        ct.fillStyle = "rgb(255,255,255)";
        ct.fillRect(0, 0, can.getBoundingClientRect().width, can.getBoundingClientRect().height);
    }

    function strokeCircle(num) { //num:何文字目か
        var p;
        if (num == 0) {
            p = 0;
        } else {
            p = 128;
        }
        ct.beginPath();
        ct.arc(64, 64 + p, 48, 0, Math.PI * 2, false);
        ct.strokeStyle = 'red';
        ct.stroke();
        ct.strokeStyle = 'black';
    }

    function strokeCross(num) { //num:何文字目か
        var p;
        if (num == 0) {
            p = 0;
        } else {
            p = 128;
        }
        ct.beginPath();
        ct.moveTo(32, 16 + p);
        ct.lineTo(16, 32 + p);
        ct.lineTo(48, 64 + p);
        ct.lineTo(16, 96 + p);
        ct.lineTo(32, 112 + p);
        ct.lineTo(64, 80 + p);
        ct.lineTo(96, 112 + p);
        ct.lineTo(112, 96 + p);
        ct.lineTo(80, 64 + p);
        ct.lineTo(112, 32 + p);
        ct.lineTo(96, 16 + p);
        ct.lineTo(64, 48 + p);
        ct.fillStyle = 'blue';
        ct.fill();
    }

    function submit() {
        var temp = document.createElement('canvas');
        temp.width = can.width / 4;
        temp.height = can.height / 4;
        var tempCtx = temp.getContext('2d');
        tempCtx.drawImage(can, 0, 0, temp.width, temp.height);
        var imageData = tempCtx.getImageData(0, 0, temp.width, temp.height);
        for (var i = 0; i < imageData.data.length / 4; i++) {
            var r = imageData.data[i * 4];
            var g = imageData.data[i * 4 + 1];
            var b = imageData.data[i * 4 + 2];
            imageData.data[i * 4] = (r + g + b) / 3;
            imageData.data[i * 4 + 1] = (r + g + b) / 3;
            imageData.data[i * 4 + 2] = (r + g + b) / 3;
        }
        var inputTensor = tf.browser.fromPixels(imageData, 3).toFloat();
        inputNormTensor = inputTensor.div(tf.scalar(255));
        var [reiTensor, waTensor] = tf.split(inputNormTensor, 2);
        reiTensor = reiTensor.reshape([1, 32, 32, 3]);
        waTensor = waTensor.reshape([1, 32, 32, 3]);
        loadPretrainedModel();
        async function loadPretrainedModel() {
            const model = await tf.loadLayersModel("{% static 'reiwa/model/model.json' %}");
            const reiPrediction = model.predict(reiTensor, {
                batchSize: 1
            });
            const waPrediction = model.predict(waTensor, {
                batchSize: 1
            });
            const rei1 = reiPrediction.arraySync()[0][0];
            const rei2 = reiPrediction.arraySync()[0][1];
            const wa = waPrediction.arraySync()[0][2];
            if ((rei1 > 0.9 || rei2 > 0.9) && wa > 0.9) {
                console.log("correct", rei1, rei2, wa);
                strokeCircle(0);
                strokeCircle(1);
            } else {
                if ((rei1 > 0.9 || rei2 > 0.9)) {
                    strokeCircle(0);
                } else {
                    strokeCross(0);
                }
                if (wa > 0.9) {
                    strokeCircle(1);
                } else {
                    strokeCross(1);
                }
            }
            setTimeout(function () {
                clearCan();
            }, 2000);
        }
    }
</script>
{% endblock %}