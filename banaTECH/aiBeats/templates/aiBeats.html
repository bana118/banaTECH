{% extends "base.html" %}
{% block title%}
ai-beats
{% endblock %}

{% block head %}
<meta name="description" content="">
<!--本番時はmin版にする-->
<script src="https://cdnjs.cloudflare.com/ajax/libs/three.js/102/three.js"></script>
<script src="https://code.createjs.com/1.0.0/soundjs.min.js"></script>
{% load static %}
<script src="{% static 'aiBeats/JavaScript/jquery.knob.min.js' %}"></script>

<style>
    body {
        margin: 0;
        overflow: hidden;
    }
</style>
{% load static %}

{% endblock %}

{% block content %}
<div id="wrap" style="position: relative;touch-action: manipulation;">
    <canvas id="myCanvas" style="position: absolute;"></canvas>
    <button type="button" class="fullScreen btn far fa-square" style="display: block;position: absolute;color: white;"
        onClick="fullScreen();"></button>
    <div class="btn-group dropleft" style="display: block;position: absolute;right: 0px;">
        <button type="button" class="dropleft btn fas fa-pause" data-toggle="dropdown" aria-haspopup="true"
            aria-expanded="false" style="color: white;" onClick="pause();"></button>
        <div class="dropdown-menu" x-placement="left-start"
            style="position: absolute; will-change: transform; top: 0px; left: 0px; transform: translate3d(-196px, 0px, 0px);">
            <a class="dropdown-item" href="#" onClick="restart();">Restart</a>
            <a class="dropdown-item" href="/ai-beats">Music Select</a>
            <div class="dropdown-divider"></div>
            <div class="volume d-flex justify-content-center">
                <p>Volume:</p>
                <input type="text" class="volumeDial" value="100" />
            </div>
        </div>
    </div>
    <button id="play_button" type="button" class="btn btn-primary"
        style="display: block;position: absolute;top:480px; left: 270px;" onClick="sound_play();">Play</button>
</div>
<script>
    var sound, backGround, tja;
    onload = function () {
        $(".volumeDial").knob({ //音量調整ダイアルの設定
            angleOffset: 240,
            angleArc: 240,
            width: 100,
            height: 100,
            release: function (v) {
                sound.changeVolume(v);
            }
        });
        $("#myCanvas").on("click", function (e) { //ドロップダウンメニューが消えないようにする
            e.stopPropagation();
        });
        $(".navbar").on("click", function (e) { //ドロップダウンメニューが消えないようにする
            e.stopPropagation();
        });
        $(".dropdown-menu").on("click", function (e) { //ドロップダウンメニューが消えないようにする
            e.stopPropagation();
        });
        $(".fullScreen").on("click", function (e) { //ドロップダウンメニューが消えないようにする
            e.stopPropagation();
        });
        sound = new Sound("sound", "{% static 'aiBeats/music/HIBANA.ogg' %}");
        backGround = new BackGround();
        tja = new TJA("{% static 'aiBeats/tja/HIBANA.tja' %}");
        window.addEventListener('resize', onResize);
        var canvas = document.querySelector('#myCanvas');
        canvas.addEventListener('click', function (e) {
            var button = e.target.getBoundingClientRect();
            var mouseX = e.clientX - button.left;
            var mouseY = e.clientY - button.top;
            if (mouseX < backGround.width / 2) {
                backGround.leftTouch();
            } else {
                backGround.rightTouch();
            }
        }, false);
    }

    document.onkeydown = keydown;

    function keydown(event) {
        if (event.key == "f") {
            backGround.leftTouch();
        } else if (event.key == "j") {
            backGround.rightTouch();
        }
    }

    function onResize() {
        var preWidth = backGround.width;
        var preHeight = backGround.height;
        // サイズを取得
        const width = window.innerWidth;
        const height = window.innerHeight;
        console.log(width, height);
        backGround.width = width;
        backGround.height = height;
        // レンダラーのサイズを調整する
        backGround.renderer.setPixelRatio(window.devicePixelRatio);
        backGround.renderer.setSize(width, height);

        // カメラのアスペクト比を正す
        backGround.camera.aspect = width / height;
        backGround.camera.updateProjectionMatrix();


        backGround.splineObject.position.x = -backGround.width / 2;
        backGround.splineObject.position.y = -backGround.height / 2;
        backGround.leftMesh.position.x = -backGround.width / 4;
        backGround.rightMesh.position.x = backGround.width / 4;
        var MeshGeometry = new THREE.BoxBufferGeometry(backGround.width / 2, backGround.height, 1);
        backGround.leftMesh.geometry = MeshGeometry;
        backGround.rightMesh.geometry = MeshGeometry;

        backGround.torus.position.y = -backGround.height / 4;

        backGround.scoreGroup.position.y *= backGround.height / preHeight;

        backGround.renderer.render(backGround.scene, backGround.camera);
    }

    class TJA {
        constructor(src) {
            this.src = src;
            this.currentBar = 0;
            this.beat = [
                [-100, 4]
            ]; //拍子。[小節, 4分の何拍子か]
            this.bpm = [];
            this.delay = []; //遅延挿入。[小節, 遅延秒数, 未使用は1使用したら0,]
            $.ajax({
                url: this.src,
                success: function (data) {
                    tja.title = data.match(/TITLE:.*\r?\n/)[0].slice(6).replace(/\r?\n/g, "");
                    tja.offset = Number(data.match(/OFFSET:.*\r?\n/)[0].slice(7).replace(/\r?\n/g, ""));
                    var firstBpm = Number(data.match(/BPM:.*\r?\n/)[0].slice(4).replace(/\r?\n/g, ""));
                    tja.bpm.push([-100, firstBpm]);
                    var allScore = data.match(/#START[\s\S]*#END/)[0].slice(6).slice(0, -4).split(",");
                    tja.score = [];
                    var orders;
                    var order;
                    for (var i = 0; i < allScore.length; i++) {
                        if (allScore[i].match(/./)) {
                            if (allScore[i].match(/.*#.*/)) {
                                orders = allScore[i].match(/(?:\r?\n)*#.*(?:\r?\n)+/g);
                                tja.score.push(allScore[i].replace(/(\r?\n)*#.*(\r?\n)+/g, "").replace(
                                    /\r?\n/g, ""));
                                for (var j = 0; j < orders.length; j++) {
                                    order = orders[j].replace(/(\r?\n)/g, "");
                                    console.log(order);
                                    if (order.match(/#MEASURE/)) {
                                        var denominator = Number(order.slice(11, 12));
                                        var numerator = Number(order.slice(9, 10));
                                        tja.beat.push([i, numerator / (denominator / 4)]);
                                    } else if (order.match(/#BPMCHANGE/)) {
                                        tja.bpm.push([i, Number(order.slice(11))]);
                                    } else if (order.match(/#DELAY/)) {
                                        tja.delay.push([i, Number(order.slice(7), 1)]);
                                    }
                                }
                            } else {
                                tja.score.push(allScore[i].replace(/\r?\n/g, ""));
                            }
                        }
                    }
                    for (var i = 0; i < tja.score.length; i++) {
                        var bar = tja.score[i].split("");
                        for (var j = 0; j < bar.length; j++) {
                            if (bar[j] == "1" || bar[j] == "3") {
                                var circleGeometry = new THREE.CircleBufferGeometry(20, 32);
                                var redMaterial = new THREE.MeshBasicMaterial({
                                    color: 0xff0000
                                });
                                var circle = new THREE.Mesh(circleGeometry, redMaterial);
                                circle.position.y = i * backGround.speed + (j / bar
                                        .length) *
                                    backGround.speed;
                                backGround.scoreGroup.add(circle);
                            } else if (bar[j] == "2" || bar[j] == "4") {
                                var circleGeometry = new THREE.CircleBufferGeometry(20, 32);
                                var blueMaterial = new THREE.MeshBasicMaterial({
                                    color: 0x0000ff
                                });
                                var circle = new THREE.Mesh(circleGeometry, blueMaterial);
                                circle.position.y = i * backGround.speed + (j / bar
                                        .length) *
                                    backGround.speed;
                                backGround.scoreGroup.add(circle);
                            }
                        }
                    }
                }
            });
        }
    }

    class BackGround {
        constructor() {
            //初期化
            this.width = window.innerWidth;
            this.height = window.innerHeight;
            this.speed = this.height; //譜面のスピードの基準
            this.renderer = new THREE.WebGLRenderer({
                canvas: document.querySelector('#myCanvas')
            });
            this.renderer.setPixelRatio(window.devicePixelRatio);
            this.renderer.setSize(this.width, this.height);
            this.scene = new THREE.Scene();
            this.camera = new THREE.PerspectiveCamera(45, this.width / this.height);
            this.camera.position.set(0, 0, +1000);
            var MeshGeometry = new THREE.BoxBufferGeometry(this.width / 2, this.height, 1);
            var blackMaterial = new THREE.MeshBasicMaterial({
                color: 0x000000
            });
            this.leftMesh = new THREE.Mesh(MeshGeometry, blackMaterial);
            this.leftMesh.position.x = -this.width / 4;
            this.leftMesh.position.z = -10;
            this.scene.add(this.leftMesh);
            this.rightMesh = new THREE.Mesh(MeshGeometry, blackMaterial);
            this.rightMesh.position.x = this.width / 4;
            this.rightMesh.position.z = -10;
            this.scene.add(this.rightMesh);

            var lineMaterial = new THREE.LineBasicMaterial({
                color: 0x00ff00
            });
            var lineGeometry = new THREE.Geometry();
            lineGeometry.vertices.push(
                new THREE.Vector3(0, this.height, -9),
                new THREE.Vector3(0, -this.height, -9),
            );
            var line = new THREE.Line(lineGeometry, lineMaterial);
            this.scene.add(line);

            var torusGeometry = new THREE.TorusGeometry(50, 5, 64, 128);
            var torusMaterial = new THREE.MeshBasicMaterial({
                color: 0x00ffff
            });
            this.torus = new THREE.Mesh(torusGeometry, torusMaterial);
            this.torus.position.y = -this.height / 4;
            this.scene.add(this.torus);

            var splineMaterial = new THREE.LineBasicMaterial({
                color: 0xffffff
            });
            var splineGeometry = new THREE.Geometry();
            this.splineObject = new THREE.Line(splineGeometry, splineMaterial);
            this.splineObject.position.x = -this.width / 2;
            this.splineObject.position.y = -this.height / 2;
            this.scene.add(this.splineObject);

            this.scoreGroup = new THREE.Object3D();
            this.scoreGroup.position.y = -this.height / 4;
            this.scene.add(this.scoreGroup);

            this.time = 0; //再生時間記録用

            this.renderer.render(this.scene, this.camera); // レンダリング
        }

        lineDraw(array) {
            var pointArray = [];
            for (var i = 0; i < sound.FFTSIZE / 2; i++) {
                var freqData = sound.freqByteData[i];
                if (!freqData) {
                    freqData = 0;
                } else {
                    freqData /= 512;
                }
                pointArray.push(new THREE.Vector2(i * this.width / (sound.FFTSIZE / 2), freqData * this.height));
            }
            var curve = new THREE.SplineCurve(pointArray);
            var points = curve.getPoints(500);
            var geometry = new THREE.BufferGeometry().setFromPoints(points);
            this.splineObject.geometry = geometry;
        }

        scoreDraw(time) { //time:曲の現在の時間
            var beatBar = 0;
            for (var i = 0; i < tja.beat.length; i++) {
                if (tja.currentBar > tja.beat[i][0]) {
                    beatBar = i;
                }
            }
            var bpmBar = 0;
            for (var i = 0; i < tja.bpm.length; i++) {
                if (tja.currentBar > tja.bpm[i][0]) {
                    bpmBar = i;
                }
            }
            var delay = 0;
            for (var i = 0; i < tja.delay.length; i++) {
                if (tja.currentBar > tja.delay[i][0] && tja.delay[i][2] != 0) {
                    delay = tja.delay[i][1];
                    tja.delay[i][2] = 0;
                    console.log(delay);
                }
            }
            tja.currentBar = tja.currentBar + (((time - this.time + delay * 1000) / 1000) * (tja.bpm[bpmBar][1] /
                60) / tja.beat[beatBar][1]);
            this.scoreGroup.position.y = this.scoreGroup.position.y - ((((time - this.time + delay * 1000) /
                1000 * (tja.bpm[bpmBar][1] / 60)) / tja.beat[beatBar][1]) * this.speed);
            this.time = time;
        }
        leftTouch() {
            var leftMeshMaterial = new THREE.MeshBasicMaterial({
                color: 0xff0000
            });
            this.leftMesh.material = leftMeshMaterial;
            this.renderer.render(this.scene, this.camera);
            setTimeout(function () {
                var blackMaterial = new THREE.MeshBasicMaterial({
                    color: 0x000000
                });
                backGround.leftMesh.material = blackMaterial;
                backGround.renderer.render(backGround.scene, backGround.camera);
            }, 50);
        }
        rightTouch() {
            var rightMeshMaterial = new THREE.MeshBasicMaterial({
                color: 0x0000ff
            });
            this.rightMesh.material = rightMeshMaterial;
            this.renderer.render(this.scene, this.camera);
            setTimeout(function () {
                var blackMaterial = new THREE.MeshBasicMaterial({
                    color: 0x000000
                });
                backGround.rightMesh.material = blackMaterial;
                backGround.renderer.render(backGround.scene, backGround.camera);
            }, 50);
        }
    }
    //フルスクリーン化
    function ElementRequestFullscreen(element) {
        var list = [
            "requestFullscreen",
            "webkitRequestFullScreen",
            "mozRequestFullScreen",
            "msRequestFullscreen"
        ];
        var i;
        var num = list.length;
        for (i = 0; i < num; i++) {
            if (element[list[i]]) {
                element[list[i]]();
                return true;
            }
        }
        return false;
    }

    //フルスクリーン要素取得
    function DocumentGetFullscreenElement(document_obj) {
        return (
            document_obj.fullscreenElement ||
            document_obj.webkitFullscreenElement ||
            document_obj.mozFullScreenElement ||
            document_obj.msFullscreenElement ||
            null
        );
    }

    //フルスクリーン解除
    function DocumentExitFullscreen(document_obj) {
        var list = [
            "exitFullscreen",
            "webkitExitFullscreen",
            "mozCancelFullScreen",
            "msExitFullscreen"
        ];
        var i;
        var num = list.length;
        for (i = 0; i < num; i++) {
            if (document_obj[list[i]]) {
                document_obj[list[i]]();
                return true;
            }
        }
        return false;
    }

    function fullScreen() {
        if (DocumentGetFullscreenElement(document) == null) {
            var element = document.getElementById("wrap");
            ElementRequestFullscreen(element);
        } else {
            DocumentExitFullscreen(document);
        }
    }

    function pause() {
        if (sound.instance != null) {
            if (sound.instance.paused == true) {
                sound.instance.paused = false
            } else {
                sound.instance.paused = true;
            }
        }
    }

    function restart() {
        if (sound.played == true) {
            sound.instance.stop();
            $('.dropleft').dropdown('hide');
            setTimeout(function () {
                sound.instance.play();
            }, 2000);
        }
    }

    class Sound {
        constructor(SOUND_ID, SOUND_PATH) {
            this.SOUND_ID = SOUND_ID;
            this.src = SOUND_PATH;
            createjs.Sound.registerSound({
                id: SOUND_ID,
                src: SOUND_PATH
            });
            this.FFTSIZE = 64;
            this.freqByteData = new Uint8Array(this.FFTSIZE / 2);
            this.plugin = new createjs.WebAudioPlugin();
            this.context = this.plugin.context;
            this.analyserNode = this.context.createAnalyser();
            this.analyserNode.connect(this.context.destination);
            this.dynamicsNode = this.plugin.dynamicsCompressorNode;
            this.dynamicsNode.disconnect();
            this.dynamicsNode.connect(this.analyserNode);
            this.instance = createjs.Sound.createInstance(this.SOUND_ID);
            this.played = false; //再生開始したかどうか
        }

        play() {
            // 音楽再生
            this.instance.play({
                loop: 0
            });
            this.played = true;
            //オフセット処理
            backGround.time = -tja.offset * 1000;
            tja.currentBar = tja.offset * (tja.bpm[0][1] / 60) / 4 + 1;
            tick();

            // 毎フレーム時に実行されるループイベント
            function tick() {
                sound.analyserNode.getByteFrequencyData(sound.freqByteData);
                backGround.lineDraw(sound.freqByteData);
                backGround.scoreDraw(sound.instance.position);
                backGround.renderer.render(backGround.scene, backGround.camera); // レンダリング

                requestAnimationFrame(tick);
            }
        }

        changeVolume(v) {
            sound.instance.volume = v / 100;
        }
    }

    function sound_play() {
        var button = document.getElementById("play_button");
        button.style.display = "none";
        sound.play();
    }
</script>
{% endblock %}