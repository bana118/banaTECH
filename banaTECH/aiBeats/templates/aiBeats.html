{% extends "base.html" %}
{% block title%}
ai-beats
{% endblock %}

{% block head %}
<meta name="description" content="">
<!--本番時はmin版にする-->
<script src="https://cdnjs.cloudflare.com/ajax/libs/three.js/102/three.js"></script>
<script src="https://code.createjs.com/1.0.0/soundjs.min.js"></script>
<style>
    body {
        margin: 0;
        overflow: hidden;
    }
</style>
{% load static %}

{% endblock %}

{% block content %}
<div id="wrap" style="position: relative;touch-action: manipulation;">
    <canvas id="myCanvas" style="position: absolute;"></canvas>
    <button type="button" class="btn far fa-square" style="display: block;position: absolute;color: white;"
        onClick="fullScreen();"></button>
    <button type="button" class="btn fas fa-pause"
        style="display: block;position: absolute;right: 0px;color: white;"></button>
    <button id="play_button" type="button" class="btn btn-primary"
        style="display: block;position: absolute;top:480px; left: 270px;" onClick="sound_play();">Play</button>
</div>
<script>
    var sound, backGround;
    onload = function () {
        sound = new Sound("sound", "{% static 'aiBeats/music/HIBANA.mp3' %}");
        backGround = new BackGround();
        window.addEventListener('resize', onResize);
        var canvas = document.querySelector('#myCanvas');
        canvas.addEventListener('click', function (e) {
            var button = e.target.getBoundingClientRect();
            var mouseX = e.clientX - button.left;
            var mouseY = e.clientY - button.top;
            if(mouseX < backGround.width /2){
                backGround.leftTouch();
            }else{
                backGround.rightTouch();
            }
        }, false);
    }

    document.onkeydown = keydown;

    function keydown(event) {
        if (event.key == "f") {
            backGround.leftTouch();
        } else if (event.key == "j") {
            backGround.rightTouch();
        }
    }

    function onResize() {
        // サイズを取得
        const width = window.innerWidth;
        const height = window.innerHeight;
        backGround.width = width;
        backGround.height = height;
        // レンダラーのサイズを調整する
        backGround.renderer.setPixelRatio(window.devicePixelRatio);
        backGround.renderer.setSize(width, height);

        // カメラのアスペクト比を正す
        backGround.camera.aspect = width / height;
        backGround.camera.updateProjectionMatrix();

        backGround.splineObject.position.x = -backGround.width / 2;
        backGround.splineObject.position.y = -backGround.height / 2;
        backGround.leftMesh.position.x = -backGround.width / 4;
        backGround.rightMesh.position.x = backGround.width / 4;
        var MeshGeometry = new THREE.BoxBufferGeometry(backGround.width / 2, backGround.height, 1);
        backGround.leftMesh.geometry = MeshGeometry;
        backGround.rightMesh.geometry = MeshGeometry;
    }

    class BackGround {
        constructor() {
            //初期化
            this.width = window.innerWidth;
            this.height = window.innerHeight;
            this.renderer = new THREE.WebGLRenderer({
                canvas: document.querySelector('#myCanvas')
            });
            this.renderer.setPixelRatio(window.devicePixelRatio);
            this.renderer.setSize(this.width, this.height);
            this.scene = new THREE.Scene();
            this.camera = new THREE.PerspectiveCamera(45, this.width / this.height);
            this.camera.position.set(0, 0, +1000);
            var MeshGeometry = new THREE.BoxBufferGeometry(this.width / 2, this.height, 1);
            var blackMaterial = new THREE.MeshBasicMaterial({
                color: 0x000000
            });
            this.leftMesh = new THREE.Mesh(MeshGeometry, blackMaterial);
            this.leftMesh.position.x = -this.width / 4;
            this.leftMesh.position.z = -10;
            this.scene.add(this.leftMesh);
            this.rightMesh = new THREE.Mesh(MeshGeometry, blackMaterial);
            this.rightMesh.position.x = this.width / 4;
            this.rightMesh.position.z = -10;
            this.scene.add(this.rightMesh);

            var splineMaterial = new THREE.LineBasicMaterial({
                color: 0xffffff
            });
            var splineGeometry = new THREE.Geometry();
            this.splineObject = new THREE.Line(splineGeometry, splineMaterial);
            this.splineObject.position.x = -this.width / 2;
            this.splineObject.position.y = -this.height / 2;
            this.scene.add(this.splineObject);

            this.renderer.render(this.scene, this.camera); // レンダリング
        }

        lineDraw(array) {
            var pointArray = [];
            for (var i = 0; i < sound.FFTSIZE / 2; i++) {
                var freqData = sound.freqByteData[i];
                if (!freqData) {
                    freqData = 0;
                } else {
                    freqData /= 512;
                }
                pointArray.push(new THREE.Vector2(i * this.width / (sound.FFTSIZE / 2), freqData * this.height));
            }
            var curve = new THREE.SplineCurve(pointArray);
            var points = curve.getPoints(500);
            var geometry = new THREE.BufferGeometry().setFromPoints(points);
            this.splineObject.geometry = geometry;
            this.renderer.render(this.scene, this.camera);
        }

        leftTouch() {
            var leftMeshMaterial = new THREE.MeshBasicMaterial({
                color: 0xff0000
            });
            this.leftMesh.material = leftMeshMaterial;
            this.renderer.render(this.scene, this.camera);
            setTimeout(function () {
                var blackMaterial = new THREE.MeshBasicMaterial({
                    color: 0x000000
                });
                backGround.leftMesh.material = blackMaterial;
                backGround.renderer.render(backGround.scene, backGround.camera);
            }, 50);
        }
        rightTouch() {
            var rightMeshMaterial = new THREE.MeshBasicMaterial({
                color: 0x0000ff
            });
            this.rightMesh.material = rightMeshMaterial;
            this.renderer.render(this.scene, this.camera);
            setTimeout(function () {
                var blackMaterial = new THREE.MeshBasicMaterial({
                    color: 0x000000
                });
                backGround.rightMesh.material = blackMaterial;
                backGround.renderer.render(backGround.scene, backGround.camera);
            }, 50);
        }
    }
    //フルスクリーン化
    function ElementRequestFullscreen(element) {
        var list = [
            "requestFullscreen",
            "webkitRequestFullScreen",
            "mozRequestFullScreen",
            "msRequestFullscreen"
        ];
        var i;
        var num = list.length;
        for (i = 0; i < num; i++) {
            if (element[list[i]]) {
                element[list[i]]();
                return true;
            }
        }
        return false;
    }

    //フルスクリーン要素取得
    function DocumentGetFullscreenElement(document_obj) {
        return (
            document_obj.fullscreenElement ||
            document_obj.webkitFullscreenElement ||
            document_obj.mozFullScreenElement ||
            document_obj.msFullscreenElement ||
            null
        );
    }

    //フルスクリーン解除
    function DocumentExitFullscreen(document_obj) {
        var list = [
            "exitFullscreen",
            "webkitExitFullscreen",
            "mozCancelFullScreen",
            "msExitFullscreen"
        ];
        var i;
        var num = list.length;
        for (i = 0; i < num; i++) {
            if (document_obj[list[i]]) {
                document_obj[list[i]]();
                return true;
            }
        }
        return false;
    }

    function fullScreen() {
        if (DocumentGetFullscreenElement(document) == null) {
            var element = document.getElementById("wrap");
            ElementRequestFullscreen(element);
        } else {
            DocumentExitFullscreen(document);
        }
    }

    class Sound {
        constructor(SOUND_ID, SOUND_PATH) {
            this.SOUND_ID = SOUND_ID;
            this.src = SOUND_PATH;
            createjs.Sound.registerSound({
                id: SOUND_ID,
                src: SOUND_PATH
            });
            this.FFTSIZE = 64;
            this.freqByteData = new Uint8Array(this.FFTSIZE / 2);
            this.plugin = new createjs.WebAudioPlugin();
            this.context = this.plugin.context;
            this.analyserNode = this.context.createAnalyser();
            this.analyserNode.connect(this.context.destination);
            this.dynamicsNode = this.plugin.dynamicsCompressorNode;
            this.dynamicsNode.disconnect();
            this.dynamicsNode.connect(this.analyserNode);

        }

        play() {
            // 無限ループで再生
            createjs.Sound.play(this.SOUND_ID, {
                loop: -1
            });
            tick();

            // 毎フレーム時に実行されるループイベント
            function tick() {
                sound.analyserNode.getByteFrequencyData(sound.freqByteData);
                backGround.lineDraw(sound.freqByteData);
                //renderer.render(scene, camera); // レンダリング

                requestAnimationFrame(tick);
            }
        }
    }

    function sound_play() {
        var button = document.getElementById("play_button");
        button.style.display = "none";
        sound.play();
    }
</script>
{% endblock %}